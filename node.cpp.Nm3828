#include <iostream>
#include <string>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "diffconsts.h"
#include "node.h"

const char GraphHeader[] = "digraph G{\n "
                                  "node [style=\"filled\", fillcolor=\"orange\", fontcolor=\"blue\"];\n";

Node::Node() {}

Node::Node(int type, nod_val val) {
    switch(type) {
    //case OP:
    case NUM: {
        this->type = type;
        this->val  = val;
        break;
    }
    case OP: {
        fprintf(stderr, "Node::Construct for numbers used for operation!\n");
        NodeSet(type, val, new Node(NUM, 0), new Node(NUM, 0));
        break;
    }
    case VAR: {
        fprintf(stderr, "Node::Construct for numbers used for variable!\n");
        NodeSet(type);
        break;
    }
    default:
        this->type = type;
        this->val  = val;
        fprintf(stderr, "Node::Construct: unknown type!\n");
    }
}

Node::Node(int type) {
    switch(type) {
    case VAR:
        this->val = 'x';
        this->type = VAR;
        break;
    case NUM:
        fprintf(stderr, "Node::Construct for variables used for number!\n");
        NodeSet(type, 0);
        break;
    case OP:
        fprintf(stderr, "Node::Construct for variables used for operation!\n");
        NodeSet(type, 0, new Node(NUM, 0), new Node(NUM, 0));
        break;
    default:
        fprintf(stderr, "Node::Construct: unknown type!\n");
    }
}

Node::Node(int type, nod_val val, Node* left, Node* right) {
    switch(type) {
    case OP: {
        this->type  = type;
        this->val   = val;
        if(this->left == NULL) {
            fprintf(stderr, "Node::Construct: left child of operation node is NULL!\n");
            this->left = new Node(NUM, 0);
        }
        else
            this->left  = left;
        this->right = right;
        break;
    }
    case VAR: {
        if(left != NULL || right != NULL)
            fprintf(stderr, "Node::Construct for operation used for variable!\n");
        NodeSet(type);
        break;
    }
    case NUM: {
        if(left != NULL || right != NULL)
            fprintf(stderr, "Node::Construct for operation used for number!\n");
        NodeSet(type, val);
        break;
    }
    default: {
        this->type  = type;
        this->val   = val;
        this->left  = left;
        this->right = right;
        fprintf(stderr, "Node::Construct: unknown type!\n");
    }
    }
}

Node::Node(int type, nod_val val, Node* left) {
    assert(left  != NULL);
    switch(type) {
    case NUM:
    case OP: {
        this->type  = type;
        this->val   = val;
        this->left  = left;
        break;
    }
    case VAR: {
        fprintf(stderr, "Node::Construct for operation & numbers used for variable!\n");
        NodeSet(type);
        break;
    }
    default:
        this->type  = type;
        this->val   = val;
        this->left  = left;
        fprintf(stderr, "Node::Construct: unknown type!\n");
    }
}

Node::~Node() {
    if(this->left != NULL)
        delete this->left;
    if(this->right != NULL)
        delete this->right;
}

void Node::NodeSet(int type, nod_val val) {
    if(type != OP && type != VAR && type != NUM)
        fprintf(stderr, "Node::NodeSet: unknown type!\n");
    this->type  = type;
    this->val   = val;
}

void Node::NodeSet(int type) {
    if(type != OP && type != VAR && type != NUM)
        fprintf(stderr, "Node::NodeSet: unknown type!\n");
    this->type  = type;
    this->val   = 'x';
}

void Node::NodeSet(int type, nod_val val, Node* left, Node* right) {
    if(type != OP && type != VAR && type != NUM)
        fprintf(stderr, "Node::NodeSet: unknown type!\n");
    this->type  = type;
    this->val   = val;
    this->left  = left;
    this->right = right;
}

void Node::NodeSet(int type, nod_val val, Node* left) {
    if(type != OP && type != VAR && type != NUM)
        fprintf(stderr, "Node::NodeSet: unknown type!\n");
    this->type  = type;
    this->val   = val;
    this->left  = left;
}

Node* Node::NodeCopy() {
    Node* left = NULL;
    Node* right = NULL;
    if(this->left != NULL)
        left = this->left->NodeCopy();
    if(this->right != NULL)
        right = this->right->NodeCopy();
    return new Node(this->type, this->val, left, right);
}

int Node::FPrintGraphNode(FILE* fd) { //Создание графа (вспомогатльная функция)
    long id = this - (Node*)0x0; //Уникальный идентификатор для каждого узла, чтобы строить корректный граф
    long leftid  = 0;
    long rightid = 0;
    if(this->left != NULL) {
        leftid = this->left - (Node*)0x0;
        fprintf(fd, "%ld [label = ", leftid);
        if(this->left->type == NUM) {
            fprintf(fd, "\"%d\"]\n", this->left->val);
        }
        else
            fprintf(fd, "\"%c\"]\n", this->left->val);
        fprintf(fd, "%ld -> %ld\n", id, leftid);
    }
    if(this->right != NULL) {
        rightid = this->right - (Node*)0x0;
        fprintf(fd, "%ld [label = ", rightid);
        if(this->right->type == NUM) {
            fprintf(fd, "\"%d\"]\n", this->right->val);
        }
        else
            fprintf(fd, "\"%c\"]\n", this->right->val);
        fprintf(fd, "%ld -> %ld\n", id, rightid);
    }
    if(this->left != NULL)
        this->left->Node::FPrintGraphNode(fd);
    if(this->right != NULL)
        this->right->Node::FPrintGraphNode(fd);
    return 0;
}

int Node::MakeGraphFile(char* FileName) { //Создание графа
    assert(FileName != NULL);
    FILE* fd;
    if((fd = fopen(FileName, "w")) == NULL) {
        perror("fopen");
        return -1;
    }
    fputs(GraphHeader, fd);
    long id = this - (Node*)0x0;
    fprintf(fd, "%ld [label = ", id);
    if(this->type == NUM) {
        fprintf(fd, "\"%d\"]\n", this->val);
    }
    else
        fprintf(fd, "\"%c\"]\n", this->val);
    this->Node::FPrintGraphNode(fd);
    fprintf(fd, "}\n");
    fclose(fd);
    return 0;
}

/*int Node::FPrintLeftNode(FILE* fd) {
    assert(fd != NULL);
    printf("(%d %d\n", this->type, this->val);
    fprintf(fd, "(%d %d\n", this->type, this->val);
    if(this->left != NULL)
        this->left->FPrintLeftNode(fd);
    if(this->right != NULL)
        this->right->FPrintRightNode(fd);
    else if(this->left != NULL) {
        printf(")\n");
        fprintf(fd, ")\n");
    }
    return 0;
}*/

int Node::FPrintNode(FILE* fd) {
    assert(fd != NULL);
    printf("%d %d\n", this->type, this->val);
    fprintf(fd, "%d %d\n", this->type, this->val);
    if(this->left != NULL) {
        printf("(");
        fprintf(fd, "(");
        this->left->Node::FPrintNode(fd);
    }
    if(this->right != NULL) {
        printf(",");
        fprintf(fd, ",");
        this->right->Node::FPrintNode(fd);
        printf(")\n");
        fprintf(fd, ")\n");
    }
    else if(this->left != NULL) {
        printf(")\n");
        fprintf(fd, ")\n");
    }
    //printf(")\n");
    //fprintf(fd, ")\n");
    return 0;
}

int Node::SaveTree(char* filename) {
    assert(filename != NULL);
    FILE* fd;
    if((fd = fopen(filename, "w")) == NULL) {
        perror("fopen");
        return -1;
    }
    printf("%d %d\n", this->type, this->val);
    fprintf(fd, "%d %d\n", this->type, this->val);
    if(this->left != NULL)
        this->left->Node::FPrintNode(fd);
    if(this->right != NULL)
        this->right->Node::FPrintNode(fd);
    fclose(fd);
    return 0;
}

void Node::TreeConstruct(char* filename) {
    assert(filename != NULL);
    FILE* fd;
    if((fd = fopen(filename, "r")) == NULL) {
        perror("fopen");
        return;
    }
    //tqueue queue;
    //if(fgets(nod->name, MAX_NAME_LEN, fd) == NULL)
    //    return -1;
    this->left = NULL;
    this->right = NULL;
    if(fscanf(fd, "%d%d", &this->type, &this->val) == EOF) {
        fclose(fd);
        return;
    }
    char buff[MAX_NAME_LEN+1];
    fgets(buff, MAX_NAME_LEN, fd);
    this->FScanNode(buff, fd);
    //queue.cur = 0;
    fclose(fd);
}

int Node::FScanNode(char* CurStr, FILE* fd) {
    assert(fd  != NULL);
    //char buff[MAX_NAME_LEN+1];
    if(fgets(CurStr, MAX_NAME_LEN + 1, fd) == NULL || CurStr[0] == '\n') {
        return -1;
    }
    else {
        int BuffLen = strlen(CurStr);
        if(BuffLen > 0 && CurStr[BuffLen - 1] == '\n')
            CurStr[BuffLen - 1] = '\0';
        if(CurStr[0] != '(')
            return 0;
        else {
            this->left = new Node;
            sscanf(CurStr + 1, "%d%d", &this->left->type, &this->left->val);
            if(this->left->Node::FScanNode(CurStr, fd) == -1) return -1;
            if(CurStr[0] != ',') {
                if(CurStr[0] != ')') {
                    fprintf(stderr, "Invalid format of input file!!!\n");
                    return -1;
                }
            }
            else {
                this->right = new Node;
                sscanf(CurStr + 1, "%d%d", &this->right->type, &this->right->val);
                if(this->right->Node::FScanNode(CurStr, fd) == -1) return -1;
                if(CurStr[0] != ')') {
                    fprintf(stderr, "Invalid format of input file!!!\n");
                    return -1;
                }
            }
            fgets(CurStr, MAX_NAME_LEN + 1, fd);
        }
    }
    return 0;
}

int Node::NumberOfNodes() {
    int i = 0;
    if(this->left != NULL)
        i += this->left->NumberOfNodes();
    if(this->right != NULL)
        i += this->right->NumberOfNodes();
    return i + 1;
}

nod_val Node::TreeCount() { //Калькулятор дерева
    switch(this->type) {
    case OP:
        if(this->left == NULL) {
            fprintf(stderr, "There is broken tree after operation \"%c\"!\n", this->val);
            return 0;
        }
        switch(this->val) {
        case '+':
            if(this->right == NULL) {
                fprintf(stderr, "There is broken tree after operation \"%c\"!\n", this->val);
            }
            return this->left->TreeCount() + this->right->TreeCount();
        case '-':
            if(this->right == NULL) {
                //fprintf(stderr, "There is broken tree after operation \"%c\"!\n", this->val);
                return (nod_val)((-1) * this->left->TreeCount());
            }
            return this->left->TreeCount() - this->right->TreeCount();
        case '*':
            if(this->right == NULL) {
                fprintf(stderr, "There is broken tree after operation \"%c\"!\n", this->val);
            }
            return this->left->TreeCount() * this->right->TreeCount();
        case '/':
            if(this->right == NULL) {
                fprintf(stderr, "There is broken tree after operation \"%c\"!\n", this->val);
            }
            return this->left->TreeCount() / this->right->TreeCount();
        case '^':
            if(this->right == NULL) {
                fprintf(stderr, "There is broken tree after operation \"%c\"!\n", this->val);
            }
            return (nod_val)pow(this->left->TreeCount(), this->right->TreeCount());
        case 's':
            return (nod_val)sin(this->left->TreeCount());
        case 'c':
            return (nod_val)cos(this->left->TreeCount());
        default:
            fprintf(stderr, "There is broken tree, unknown operation \"%c\"!\n", this->val);
            return 0;
        }
        break;
    case NUM:
        return this->val;
    case VAR:
        return 0;
    default:
        fprintf(stderr, "There is broken tree, unknown type number \"%d\"!\n", this->type);
        return 0;
    }
}

Node* Node::operator +(Node* other) {
    return new Node(OP, '+', this, other);
}

Node* Node::operator -(Node* other) {
    return new Node(OP, '-', this, other);
}

Node* Node::operator *(Node* other) {
    return new Node(OP, '*', this, other);
}

Node* Node::operator /(Node* other) {
    return new Node(OP, '/', this, other);
}

Node* Node::operator ^(Node* other) {
    return new Node(OP, '^', this, other);
}

Node* Node::operator ^(int other) {
    return new Node(OP, '^', this, new Node(NUM, other));
}

Node* Node::Diff() {
    if(this->type == NUM)
        return new Node(NUM, 0);
    if(this->type == VAR)
        return new Node(NUM, 1);
    if(this->type != OP) {
        fprintf(stderr, "Unknown type of node!\n");
        return NULL;
    }

    switch (this->val) {
    case '+':
        return *this->left->Diff() + this->right->Diff();
        break;
    case '-':
        if(this->right == NULL) {
            return
        }
        return *this->left->Diff() - this->right->Diff();
        break;
    case '*':
        return *(*this->left->Diff() * this->right->NodeCopy()) + (*this->left->NodeCopy() * this->right->Diff());
        break;
    case '/':
        return *(*(*this->left->Diff() * this->right->NodeCopy()) - (*this->left->NodeCopy() * this->right->Diff())) / (*this->right->NodeCopy() ^ 2);
        break;
    case 's':
        if(this->left == NULL) {
            fprintf(stderr, "Diff: No argument in sin!\n"); //argument of sin/cos must be left child
            return this->NodeCopy();
        }
        return *new Node(OP, 'c', this->left->NodeCopy()) * this->left->Diff();
        break;
    case 'c':
        if(this->left == NULL) {
            fprintf(stderr, "Diff: No argument in cos!\n"); //argument of cos/sin must be left child
            return this->NodeCopy();
        }
        return *(*new Node(NUM, 0) - new Node(OP, 's', this->left->NodeCopy())) * this->left->Diff();
        break;
    default:
        fprintf(stderr, "Unknown operation \"%c\"!\n", this->val);
        return NULL;
        break;
    }
}

int Node::Optimization() {
    switch(this->type) {
    case NUM:
        return this->val;
    case VAR:
        return -1;
    case OP: {
        int LeftVal = 0;
        int RightVal = 0;
        if(this->left != NULL)
            LeftVal  = this->left->Optimization();
        if(this->right != NULL)
            RightVal = this->right->Optimization();
        Node* Left = this->left;
        Node* Right = this->right;
        switch (this->val) {
        case '+':
        case '-':
            if(RightVal == 0 && LeftVal == 0) {
                delete this->left;
                delete this->right;
                this->left  = NULL;
                this->right = NULL;
                this->NodeSet(NUM, 0);
                return 0;
            }
            else if(RightVal == 0) {
                delete this->right;
                this->right = NULL;
                this->NodeSet(this->left->type, this->left->val, this->left->left, this->left->right);
                Left->left = NULL;
                Left->right = NULL;
                delete Left;
                return this->val;
            }
            else if(LeftVal == 0) {
                delete this->left;
                this->left = NULL;
                if(this->val == '-')
                    return '-';
                this->NodeSet(this->right->type, this->right->val, this->right->left, this->right->right);
                Right->left = NULL;
                Right->right = NULL;
                delete Right;
                return this->val;
            }
            break;

        case '*':
            if(LeftVal == 0 || RightVal == 0) {
                delete this->left;
                delete this->right;
                this->left  = NULL;
                this->right = NULL;
                this->NodeSet(NUM, 0);
                return 0;
            }
            else if (RightVal == 1 && LeftVal == 1) {
                delete this->left;
                delete this->right;
                this->left  = NULL;
                this->right = NULL;
                this->NodeSet(NUM, 1);
                return 1;
            }
            else if(RightVal == 1) {
                delete this->right;
                this->right = NULL;
                this->NodeSet(this->left->type, this->left->val, this->left->left, this->left->right);
                Left->left = NULL;
                Left->right = NULL;
                delete Left;
                return this->val;
            }
            else if(LeftVal == 1) {
                delete this->left;
                this->left = NULL;
                this->NodeSet(this->right->type, this->right->val, this->right->left, this->right->right);
                Right->left = NULL;
                Right->right = NULL;
                delete Right;
                return this->val;
            }
            break;
        case '/':
            if(RightVal == 0) {
                fprintf(stderr, "В дереве есть деление на ноль!\n");
                return '/';
            }
            else if(LeftVal == 0) {
                delete this->left;
                delete this->right;
                this->left  = NULL;
                this->right = NULL;
                this->NodeSet(NUM, 0);
                return 0;
            }
            else if (RightVal == 1 && LeftVal == 1) {
                delete this->left;
                delete this->right;
                this->left  = NULL;
                this->right = NULL;
                this->NodeSet(NUM, 1);
                return 1;
            }
            else if(RightVal == 1) {
                delete this->right;
                this->right = NULL;
                this->NodeSet(this->left->type, this->left->val, this->left->left, this->left->right);
                Left->left = NULL;
                Left->right = NULL;
                delete Left;
                return this->val;
            }
            break;
        case 's':
        case 'c':
            if(LeftVal == 0) {
                delete this->left;
                this->left  = NULL;
                if(this->val == 's')
                    this->NodeSet(NUM, 0);
                else
                    this->NodeSet(NUM, 1);
                return this->val;
            }
            break;
        case '^':
            if(LeftVal == 0) {
                if(RightVal < 0) {
                    fprintf(stderr, "В дереве есть деление на 0!\n");
                    return '^';
                }
                else {
                    delete this->left;
                    delete this->right;
                    this->left  = NULL;
                    this->right = NULL;
                    this->NodeSet(NUM, 0);
                    return 0;
                }
            }
            if(LeftVal == 1 || RightVal == 0) {
                delete this->left;
                delete this->right;
                this->left  = NULL;
                this->right = NULL;
                this->NodeSet(NUM, 1);
                return 1;
            }
            else if(RightVal == 1) {
                delete this->right;
                this->right = NULL;
                this->NodeSet(this->left->type, this->left->val, this->left->left, this->left->right);
                Left->left = NULL;
                Left->right = NULL;
                delete Left;
                return this->val;
            }
            break;
        default:
            fprintf(stderr, "Unknown operation %c!\n", this->val);
            break;
        }
        break;
    }
    default:
        fprintf(stderr, "Optimization: Unknown type \"%d\"!\n", this->type);
    }
    return this->val;
}

